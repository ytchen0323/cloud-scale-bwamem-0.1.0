#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <jni.h>
#include <jni_mate_sw.h> // generated by javah via maven-native-plugin
#include <assert.h>
#include <stdlib.h>
//#define malloc(n) debug_malloc(n, __FILE__, __LINE__)
//#define free(p) debug_free(p, __FILE__, __LINE__)

#include "bwamem.h"
#include "kvec.h"

//#define DEBUG

/* Total bytes allocated */
//static int total_allocated;
/* Memory alignment is important */
/*typedef union { double d; struct {size_t n; char *file; int line;} s; } Site;
void *
debug_malloc(size_t n, char *file, int line) 
{ 
    char *rp;
    rp = (char*)malloc(sizeof(Site)+n); 
    total_allocated += n; 
    ((Site*)rp)->s.n = n;
    ((Site*)rp)->s.file = file;
    ((Site*)rp)->s.line = line;
    return (void*)(rp + sizeof(Site));
}
void 
debug_free(void *p, char *file, int line)
{
    char *rp;
    rp = ((char*)p) - sizeof(Site);
    total_allocated -= ((Site*)rp)->s.n;
    free(rp);
}*/

JNIEXPORT jobjectArray JNICALL Java_cs_ucla_edu_bwaspark_jni_MateSWJNI_mateSWJNI
(JNIEnv *env, jobject thisObj, jobject opt, jlong pacLen, jobjectArray pes, jint groupSize, 
 jobjectArray inSeqSWArray, jobjectArray inMateSWArray, jobjectArray inRefSWArray, jintArray refSizeArray)
{
  int i = 0;

  // get Java classes  
  jclass MemAlnRegTypeClass = (*env)->FindClass(env, "cs/ucla/edu/bwaspark/datatype/MemAlnRegType");
#ifdef DEBUG
  if(MemAlnRegTypeClass == NULL) fprintf(stderr, "[JNI/C] Class MemAlnRegType not found\n");
  else fprintf(stderr, "[JNI/C] Class MemAlnRegType found\n");
#endif

  jclass MemOptTypeClass = (*env)->FindClass(env, "cs/ucla/edu/bwaspark/datatype/MemOptType");
#ifdef DEBUG
  if(MemOptTypeClass == NULL) fprintf(stderr, "[JNI/C] Class MemOptType not found\n");
  else fprintf(stderr, "[JNI/C] Class MemOptType found\n");
#endif

  jclass MemPeStatClass = (*env)->FindClass(env, "cs/ucla/edu/bwaspark/datatype/MemPeStat");
#ifdef DEBUG
  if(MemPeStatClass == NULL) fprintf(stderr, "[JNI/C] Class MemPeStat not found\n");
  else fprintf(stderr, "[JNI/C] Class MemPeStat found\n");
#endif

  jclass MateSWTypeClass = (*env)->FindClass(env, "cs/ucla/edu/bwaspark/jni/MateSWType");
#ifdef DEBUG
  if(MateSWTypeClass == NULL) fprintf(stderr, "[JNI/C] Class MateSWType not found\n");
  else fprintf(stderr, "[JNI/C] Class MateSWType found\n");
#endif

  jclass SeqSWTypeClass = (*env)->FindClass(env, "cs/ucla/edu/bwaspark/jni/SeqSWType");
#ifdef DEBUG
  if(SeqSWTypeClass == NULL) fprintf(stderr, "[JNI/C] Class SeqSWType not found\n");
  else fprintf(stderr, "[JNI/C] Class SeqSWType found\n");
#endif

  jclass RefSWTypeClass = (*env)->FindClass(env, "cs/ucla/edu/bwaspark/jni/RefSWType");
#ifdef DEBUG
  if(RefSWTypeClass == NULL) fprintf(stderr, "[JNI/C] Class RefSWType not found\n");
  else fprintf(stderr, "[JNI/C] Class RefSWType found\n");
#endif

  // get field IDs: MemOptType
  jfieldID aOptId = (*env)->GetFieldID(env, MemOptTypeClass, "a", "I");
  jfieldID bOptId = (*env)->GetFieldID(env, MemOptTypeClass, "b", "I");
  jfieldID oDelOptId = (*env)->GetFieldID(env, MemOptTypeClass, "oDel", "I");
  jfieldID eDelOptId = (*env)->GetFieldID(env, MemOptTypeClass, "eDel", "I");
  jfieldID oInsOptId = (*env)->GetFieldID(env, MemOptTypeClass, "oIns", "I");
  jfieldID eInsOptId = (*env)->GetFieldID(env, MemOptTypeClass, "eIns", "I");
  jfieldID penUnpairedOptId = (*env)->GetFieldID(env, MemOptTypeClass, "penUnpaired", "I");
  jfieldID penClip5OptId = (*env)->GetFieldID(env, MemOptTypeClass, "penClip5", "I");
  jfieldID penClip3OptId = (*env)->GetFieldID(env, MemOptTypeClass, "penClip3", "I");
  jfieldID wOptId = (*env)->GetFieldID(env, MemOptTypeClass, "w", "I");
  jfieldID zdropOptId = (*env)->GetFieldID(env, MemOptTypeClass, "zdrop", "I");
  jfieldID TOptId = (*env)->GetFieldID(env, MemOptTypeClass, "T", "I");
  jfieldID flagOptId = (*env)->GetFieldID(env, MemOptTypeClass, "flag", "I");
  jfieldID minSeedLenOptId = (*env)->GetFieldID(env, MemOptTypeClass, "minSeedLen", "I");
  jfieldID splitFactorOptId = (*env)->GetFieldID(env, MemOptTypeClass, "splitFactor", "F");
  jfieldID splitWidthOptId = (*env)->GetFieldID(env, MemOptTypeClass, "splitWidth", "I");
  jfieldID maxOccOptId = (*env)->GetFieldID(env, MemOptTypeClass, "maxOcc", "I");
  jfieldID maxChainGapOptId = (*env)->GetFieldID(env, MemOptTypeClass, "maxChainGap", "I");
  jfieldID chunkSizeOptId = (*env)->GetFieldID(env, MemOptTypeClass, "chunkSize", "I");
  jfieldID maskLevelOptId = (*env)->GetFieldID(env, MemOptTypeClass, "maskLevel", "F");
  jfieldID chainDropRatioOptId = (*env)->GetFieldID(env, MemOptTypeClass, "chainDropRatio", "F");
  jfieldID maskLevelRedunOptId = (*env)->GetFieldID(env, MemOptTypeClass, "maskLevelRedun", "F");
  jfieldID mapQCoefLenOptId = (*env)->GetFieldID(env, MemOptTypeClass, "mapQCoefLen", "F");
  jfieldID mapQCoefFacOptId = (*env)->GetFieldID(env, MemOptTypeClass, "mapQCoefFac", "I");
  jfieldID maxInsOptId = (*env)->GetFieldID(env, MemOptTypeClass, "maxIns", "I");
  jfieldID maxMateswOptId = (*env)->GetFieldID(env, MemOptTypeClass, "maxMatesw", "I");
  jfieldID matOptId = (*env)->GetFieldID(env, MemOptTypeClass, "mat", "[B");

  // get field IDs: MemPeStat
  jfieldID lowPeStatId = (*env)->GetFieldID(env, MemPeStatClass, "low", "I");
  jfieldID highPeStatId = (*env)->GetFieldID(env, MemPeStatClass, "high", "I");
  jfieldID failedPeStatId = (*env)->GetFieldID(env, MemPeStatClass, "failed", "I");
  jfieldID avgPeStatId = (*env)->GetFieldID(env, MemPeStatClass, "avg", "D");
  jfieldID stdPeStatId = (*env)->GetFieldID(env, MemPeStatClass, "std", "D");
  
  // get field IDs: SeqSWType
  jfieldID readIdxSeqSWId = (*env)->GetFieldID(env, SeqSWTypeClass, "readIdx", "I");
  jfieldID pairIdxSeqSWId = (*env)->GetFieldID(env, SeqSWTypeClass, "pairIdx", "I");
  jfieldID seqLengthSeqSWId = (*env)->GetFieldID(env, SeqSWTypeClass, "seqLength", "I");
  jfieldID seqTransSeqSWId = (*env)->GetFieldID(env, SeqSWTypeClass, "seqTrans", "[B");

  // get field IDs: MateSWType
  jfieldID readIdxId = (*env)->GetFieldID(env, MateSWTypeClass, "readIdx", "I");
  jfieldID pairIdxId = (*env)->GetFieldID(env, MateSWTypeClass, "pairIdx", "I");
  jfieldID regIdxId = (*env)->GetFieldID(env, MateSWTypeClass, "regIdx", "I");
  jfieldID alnRegId = (*env)->GetFieldID(env, MateSWTypeClass, "alnReg", "Lcs/ucla/edu/bwaspark/datatype/MemAlnRegType;");

  // get field IDs: RefSWType
  jfieldID refReadIdxId = (*env)->GetFieldID(env, RefSWTypeClass, "readIdx", "I");
  jfieldID refPairIdxId = (*env)->GetFieldID(env, RefSWTypeClass, "pairIdx", "I");
  jfieldID refRegIdxId = (*env)->GetFieldID(env, RefSWTypeClass, "regIdx", "I");
  jfieldID rBegArrayId = (*env)->GetFieldID(env, RefSWTypeClass, "rBegArray", "[J");
  jfieldID rEndArrayId = (*env)->GetFieldID(env, RefSWTypeClass, "rEndArray", "[J");
  jfieldID lenArrayId = (*env)->GetFieldID(env, RefSWTypeClass, "lenArray", "[J");
  jfieldID ref0Id = (*env)->GetFieldID(env, RefSWTypeClass, "ref0", "[B");
  jfieldID ref1Id = (*env)->GetFieldID(env, RefSWTypeClass, "ref1", "[B");
  jfieldID ref2Id = (*env)->GetFieldID(env, RefSWTypeClass, "ref2", "[B");
  jfieldID ref3Id = (*env)->GetFieldID(env, RefSWTypeClass, "ref3", "[B");

  // get field IDs: MemAlnRegType
  jfieldID rBegId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "rBeg", "J");
  jfieldID rEndId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "rEnd", "J");
  jfieldID qBegId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "qBeg", "I");
  jfieldID qEndId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "qEnd", "I");
  jfieldID scoreId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "score", "I");
  jfieldID trueScoreId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "trueScore", "I");
  jfieldID subId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "sub", "I");
  jfieldID csubId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "csub", "I");
  jfieldID subNumId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "subNum", "I");
  jfieldID widthId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "width", "I");
  jfieldID seedCovId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "seedCov", "I");
  jfieldID secondaryId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "secondary", "I");
  jfieldID hashId = (*env)->GetFieldID(env, MemAlnRegTypeClass, "hash", "J");

  // get and print MemOptType values
  mem_opt_t optC;
  optC.a = (*env)->GetIntField(env, opt, aOptId);
  optC.b = (*env)->GetIntField(env, opt, bOptId);
  optC.o_del = (*env)->GetIntField(env, opt, oDelOptId);
  optC.e_del = (*env)->GetIntField(env, opt, eDelOptId);
  optC.o_ins = (*env)->GetIntField(env, opt, oInsOptId);
  optC.e_ins = (*env)->GetIntField(env, opt, eInsOptId);
  optC.pen_unpaired = (*env)->GetIntField(env, opt, penUnpairedOptId);
  optC.pen_clip5 = (*env)->GetIntField(env, opt, penClip5OptId);
  optC.pen_clip3 = (*env)->GetIntField(env, opt, penClip3OptId);
  optC.w = (*env)->GetIntField(env, opt, wOptId);
  optC.zdrop = (*env)->GetIntField(env, opt, zdropOptId);
  optC.T = (*env)->GetIntField(env, opt, TOptId);
  optC.flag = (*env)->GetIntField(env, opt, flagOptId);
  optC.min_seed_len = (*env)->GetIntField(env, opt, minSeedLenOptId);
  optC.split_factor = (*env)->GetFloatField(env, opt, splitFactorOptId);
  optC.split_width = (*env)->GetIntField(env, opt, splitWidthOptId);
  optC.max_occ = (*env)->GetIntField(env, opt, maxOccOptId);
  optC.max_chain_gap = (*env)->GetIntField(env, opt, maxChainGapOptId);
  optC.chunk_size = (*env)->GetIntField(env, opt, chunkSizeOptId);
  optC.mask_level = (*env)->GetFloatField(env, opt, maskLevelOptId);
  optC.chain_drop_ratio = (*env)->GetFloatField(env, opt, chainDropRatioOptId);
  optC.mask_level_redun = (*env)->GetFloatField(env, opt, maskLevelRedunOptId);
  optC.mapQ_coef_len = (*env)->GetFloatField(env, opt, mapQCoefLenOptId);
  optC.mapQ_coef_fac = (*env)->GetIntField(env, opt, mapQCoefFacOptId);
  optC.max_ins = (*env)->GetIntField(env, opt, maxInsOptId);
  optC.max_matesw = (*env)->GetIntField(env, opt, maxMateswOptId);
  jobject matObj = (*env)->GetObjectField(env, opt, matOptId);
  jbyteArray* matPtr = (jbyteArray*) (&matObj);
  jbyte* matC = (jbyte*) (*env)->GetByteArrayElements(env, *matPtr, NULL);
  for(i = 0; i < 25; i++)
    optC.mat[i] = (int8_t) matC[i]; 
  optC.n_threads = -1; // should not be used in JNI
#ifdef DEBUG
  fprintf(stderr, "Opt: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %f %d %d %d %d %d %f %f %f %f %d %d %d\n", 
          optC.a, optC.b, optC.o_del, optC.e_del, optC.o_ins, optC.e_ins,
          optC.pen_unpaired, optC.pen_clip5, optC.pen_clip5, optC.w, optC.zdrop, 
          optC.T, optC.flag, optC.min_seed_len, optC.split_factor, optC.split_width,
          optC.max_occ, optC.max_chain_gap, optC.n_threads, optC.chunk_size, optC.mask_level,
          optC.chain_drop_ratio, optC.mask_level_redun, optC.mapQ_coef_len, optC.mapQ_coef_fac,
          optC.max_ins, optC.max_matesw);
  for(i = 0; i < 25; i++) fprintf(stderr, "%"PRId8" ", optC.mat[i]);
  fprintf(stderr, "\n");
#endif
  (*env)->ReleaseByteArrayElements(env, *matPtr, matC, 0);
  

  // get and print MemPeStat array (pes)
  mem_pestat_t pesC[4];
  for(i = 0; i < 4; i++) {
    jobject pesObj = (*env)->GetObjectArrayElement(env, pes, i);
    pesC[i].low = (*env)->GetIntField(env, pesObj, lowPeStatId);
    pesC[i].high = (*env)->GetIntField(env, pesObj, highPeStatId);
    pesC[i].failed = (*env)->GetIntField(env, pesObj, failedPeStatId);
    pesC[i].avg = (*env)->GetDoubleField(env, pesObj, avgPeStatId);
    pesC[i].std = (*env)->GetDoubleField(env, pesObj, stdPeStatId);
#ifdef DEBUG
    fprintf(stderr, "pes[%d]: %d %d %d %lf %lf\n", i, pesC[i].low, pesC[i].high, pesC[i].failed, pesC[i].avg, pesC[i].std);
#endif
  }

  // get and print SeqSWArray
  int** seqLenPairs = (int**) malloc(sizeof(int*) * groupSize);
  assert(seqLenPairs != NULL);
  for(i = 0; i < groupSize; i++) { 
    seqLenPairs[i] = (int*) malloc(sizeof(int) * 2);
    assert(seqLenPairs[i] != NULL);
  }
  uint8_t*** seqsTransPairs = (uint8_t***) malloc(sizeof(uint8_t**) * groupSize);
  assert(seqsTransPairs != NULL);
  for(i = 0; i < groupSize; i++) {
    seqsTransPairs[i] = (uint8_t**) malloc(sizeof(uint8_t*) * 2);
    assert(seqsTransPairs[i] != NULL);
  }

  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

  jsize seqArrayLength = (*env)->GetArrayLength(env, inSeqSWArray);
#ifdef DEBUG
  fprintf(stderr, "inSeqSWArray Length: %d\n", seqArrayLength);
#endif
  for(i = 0; i < seqArrayLength; i++) {
    jobject seqObj = (*env)->GetObjectArrayElement(env, inSeqSWArray, i);
    jint readIdxInst = (*env)->GetIntField(env, seqObj, readIdxSeqSWId);
    jint pairIdxInst = (*env)->GetIntField(env, seqObj, pairIdxSeqSWId);
    jint seqLenFASTQ = (*env)->GetIntField(env, seqObj, seqLengthSeqSWId);
    jobject seqTransObj = (*env)->GetObjectField(env, seqObj, seqTransSeqSWId);
    jbyteArray* seqTransPtr = (jbyteArray*) (&seqTransObj);
    jbyte* seqTransC= (jbyte*) (*env)->GetByteArrayElements(env, *seqTransPtr, NULL);

    // copy data to arrays which are passed into mem_group_matesw()
    seqLenPairs[readIdxInst][pairIdxInst] = seqLenFASTQ;
    seqsTransPairs[readIdxInst][pairIdxInst] = (uint8_t*) malloc(sizeof(uint8_t) * seqLenFASTQ);
    assert(seqsTransPairs[readIdxInst][pairIdxInst] != NULL);
    int j = 0;
    for(j = 0; j < seqLenFASTQ; j++) seqsTransPairs[readIdxInst][pairIdxInst][j] = (uint8_t) seqTransC[j];
    //for(j = 0; j < seqLenFASTQ; j++) fprintf(stderr, "%d", seqsTransPairs[readIdxInst][pairIdxInst][j]);
    //fprintf(stderr, "\n");

    //fprintf(stderr, "Seq: %d %d %s %s %s %s %d %s\n", readIdxInst, pairIdxInst, nameStr, seqStr, qualStr, commentStr, seqLenFASTQ, samStr);
    (*env)->ReleaseByteArrayElements(env, *seqTransPtr, seqTransC, 0);
  }

  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

  // get and print MateSWArray
  jsize mateSWArrayLength = (*env)->GetArrayLength(env, inMateSWArray);
#ifdef DEBUG
  fprintf(stderr, "inMateSWArray Length: %d\n", mateSWArrayLength);
#endif

  mem_alnreg_v** alnRegVecPairs = (mem_alnreg_v**) malloc(sizeof(mem_alnreg_v*) * groupSize);
  assert(alnRegVecPairs != NULL);
  for(i = 0; i < groupSize; i++) {
    alnRegVecPairs[i] = (mem_alnreg_v*) malloc(sizeof(mem_alnreg_v) * 2);
    assert(alnRegVecPairs[i] != NULL);
    int j = 0;
    for(j = 0; j < 2; j++) {
      kv_init(alnRegVecPairs[i][j]);
    }
  }

  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

  for(i = 0; i < mateSWArrayLength; i++) {
    jobject objMateSW = (*env)->GetObjectArrayElement(env, inMateSWArray, i);
    jint readIdxInst = (*env)->GetIntField(env, objMateSW, readIdxId);
    jint pairIdxInst = (*env)->GetIntField(env, objMateSW, pairIdxId);
    jint regIdxInst = (*env)->GetIntField(env, objMateSW, regIdxId);
    jobject alnRegObj = (*env)->GetObjectField(env, objMateSW, alnRegId);

    mem_alnreg_t aln;
    memset(&aln, 0, sizeof(mem_alnreg_t));

    jlong alnRegRBeg = (*env)->GetLongField(env, alnRegObj, rBegId);
    jlong alnRegREnd = (*env)->GetLongField(env, alnRegObj, rEndId);
    jint alnRegQBeg = (*env)->GetIntField(env, alnRegObj, qBegId);
    jint alnRegQEnd = (*env)->GetIntField(env, alnRegObj, qEndId);
    jint alnRegScore = (*env)->GetIntField(env, alnRegObj, scoreId);
    jint alnRegTrueScore = (*env)->GetIntField(env, alnRegObj, trueScoreId);
    jint alnRegSub = (*env)->GetIntField(env, alnRegObj, subId);
    jint alnRegCSub = (*env)->GetIntField(env, alnRegObj, csubId);
    jint alnRegSubNum = (*env)->GetIntField(env, alnRegObj, subNumId);
    jint alnRegWidth = (*env)->GetIntField(env, alnRegObj, widthId);
    jint alnRegSeedCov = (*env)->GetIntField(env, alnRegObj, seedCovId);
    jint alnRegSecondary = (*env)->GetIntField(env, alnRegObj, secondaryId);
    jlong alnRegHash = (*env)->GetLongField(env, alnRegObj, hashId);

    aln.rb = (int64_t) (*env)->GetLongField(env, alnRegObj, rBegId);
    aln.re = (int64_t) (*env)->GetLongField(env, alnRegObj, rEndId);
    aln.qb = (int) (*env)->GetIntField(env, alnRegObj, qBegId);
    aln.qe = (int) (*env)->GetIntField(env, alnRegObj, qEndId);
    aln.score = (int) (*env)->GetIntField(env, alnRegObj, scoreId);
    aln.truesc = (int) (*env)->GetIntField(env, alnRegObj, trueScoreId);
    aln.sub = (int) (*env)->GetIntField(env, alnRegObj, subId);
    aln.csub =(int)  (*env)->GetIntField(env, alnRegObj, csubId);
    aln.sub_n = (int) (*env)->GetIntField(env, alnRegObj, subNumId);
    aln.w = (int) (*env)->GetIntField(env, alnRegObj, widthId);
    aln.seedcov = (int) (*env)->GetIntField(env, alnRegObj, seedCovId);
    aln.secondary = (int) (*env)->GetIntField(env, alnRegObj, secondaryId);
    aln.hash = (uint64_t) (*env)->GetLongField(env, alnRegObj, hashId);
    kv_push(mem_alnreg_t, alnRegVecPairs[readIdxInst][pairIdxInst], aln);   
    //kv_push(mem_alnreg_t, alnRegTmpVecPairs[readIdxInst][pairIdxInst], aln);
    //fprintf(stderr, "Index: %d %d %d\n", readIdxInst, pairIdxInst, alnRegTmpVecPairs[readIdxInst][pairIdxInst].n);

    //fprintf(stderr, "Reg: %ld %ld %d %d %d %d %d %d %d %d %d %d %ld\n", alnRegRBeg, alnRegREnd, alnRegQBeg, alnRegQEnd, alnRegScore, alnRegTrueScore, alnRegSub, alnRegCSub, alnRegSubNum, alnRegWidth, alnRegSeedCov, alnRegSecondary, alnRegHash);

    //fprintf(stderr, "%d %d %d\n", readIdxInst, pairIdxInst, regIdxInst);
  }

  // get and print RefSWArray
  jsize refSWArrayLength = (*env)->GetArrayLength(env, inRefSWArray);
#ifdef DEBUG
  fprintf(stderr, "inRefSWArray Length: %d\n", refSWArrayLength);
#endif

  jint* refSizeArrayC = (*env)->GetIntArrayElements(env, refSizeArray, NULL);
  jsize refSizeArrayCLength = (*env)->GetArrayLength(env, refSizeArray);
#ifdef DEBUG
  fprintf(stderr, "refSizeArrayCLength: %d\n", refSizeArrayCLength);
#endif

  ref_t**** regRefArray = (ref_t****) malloc(sizeof(ref_t***) * groupSize);
  assert(regRefArray != NULL);
  for(i = 0; i < groupSize; i++) {
    regRefArray[i] = (ref_t***) malloc(sizeof(ref_t**) * 2);
    assert(regRefArray[i] != NULL);
    int j = 0;
    for(j = 0; j < 2; j++) {
      regRefArray[i][j] = (ref_t**) malloc(sizeof(ref_t*) * refSizeArrayC[i * 2 + j]);
      assert(regRefArray[i][j] != NULL);
      int k = 0;
      for(k = 0; k < refSizeArrayC[i * 2 + j]; k++) {
        regRefArray[i][j][k] = (ref_t*) malloc(sizeof(ref_t) * 4);
        int r = 0;
        for(r = 0; r < 4; r++) regRefArray[i][j][k][r].ref = NULL;
        assert(regRefArray[i][j][k] != NULL);
      }
    }
  }

  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

  for(i = 0; i < refSWArrayLength; i++) {
    jobject objRefSW = (*env)->GetObjectArrayElement(env, inRefSWArray, i);
    jint readIdxInst = (*env)->GetIntField(env, objRefSW, refReadIdxId);
    jint pairIdxInst = (*env)->GetIntField(env, objRefSW, refPairIdxId);
    jint regIdxInst = (*env)->GetIntField(env, objRefSW, refRegIdxId);

    //fprintf(stderr, "i=%d, (%d, %d, %d)\n", i, readIdxInst, pairIdxInst, regIdxInst); 

    jobject rBegArrayObj = (*env)->GetObjectField(env, objRefSW, rBegArrayId);
    jlongArray* rBegArrayPtr = (jlongArray*) (&rBegArrayObj);
    jlong* rBegArray = (jlong*) (*env)->GetLongArrayElements(env, *rBegArrayPtr, NULL);
    jobject rEndArrayObj = (*env)->GetObjectField(env, objRefSW, rEndArrayId);
    jlongArray* rEndArrayPtr = (jlongArray*) (&rEndArrayObj);
    jlong* rEndArray = (jlong*) (*env)->GetLongArrayElements(env, *rEndArrayPtr, NULL);
    jobject lenArrayObj = (*env)->GetObjectField(env, objRefSW, lenArrayId);
    jlongArray* lenArrayPtr = (jlongArray*) (&lenArrayObj);
    jlong* lenArray = (jlong*) (*env)->GetLongArrayElements(env, *lenArrayPtr, NULL);
    
    jobject ref0Obj, ref1Obj, ref2Obj, ref3Obj;
    jbyteArray *ref0Ptr, *ref1Ptr, *ref2Ptr, *ref3Ptr;
    jbyte *ref0, *ref1, *ref2, *ref3;

    if(lenArray[0] > 0) {
      ref0Obj = (*env)->GetObjectField(env, objRefSW, ref0Id);
      ref0Ptr = (jbyteArray*) (&ref0Obj);
      ref0 = (jbyte*) (*env)->GetByteArrayElements(env, *ref0Ptr, NULL);
    }
    if(lenArray[1] > 0) {
      ref1Obj = (*env)->GetObjectField(env, objRefSW, ref1Id);
      ref1Ptr = (jbyteArray*) (&ref1Obj);
      ref1 = (jbyte*) (*env)->GetByteArrayElements(env, *ref1Ptr, NULL);
    }
    if(lenArray[2] > 0) {
      ref2Obj = (*env)->GetObjectField(env, objRefSW, ref2Id);
      ref2Ptr = (jbyteArray*) (&ref2Obj);
      ref2 = (jbyte*) (*env)->GetByteArrayElements(env, *ref2Ptr, NULL);
    }
    if(lenArray[3] > 0) {
      ref3Obj = (*env)->GetObjectField(env, objRefSW, ref3Id);
      ref3Ptr = (jbyteArray*) (&ref3Obj);
      ref3 = (jbyte*) (*env)->GetByteArrayElements(env, *ref3Ptr, NULL);
    }

    int j = 0;
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][0].rBeg = rBegArray[0];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][0].rEnd = rEndArray[0];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][0].len = lenArray[0];
    if(lenArray[0] > 0) {
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][0].ref = (uint8_t*) malloc(sizeof(uint8_t) * lenArray[0]);
      assert(regRefArray[readIdxInst][pairIdxInst][regIdxInst][0].ref != NULL);
    }
    for(j = 0; j < lenArray[0]; j++)
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][0].ref[j] = ref0[j];

    regRefArray[readIdxInst][pairIdxInst][regIdxInst][1].rBeg = rBegArray[1];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][1].rEnd = rEndArray[1];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][1].len = lenArray[1];
    if(lenArray[1] > 0) {
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][1].ref = (uint8_t*) malloc(sizeof(uint8_t) * lenArray[1]);
      assert(regRefArray[readIdxInst][pairIdxInst][regIdxInst][1].ref != NULL);
    }
    for(j = 0; j < lenArray[1]; j++)
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][1].ref[j] = ref1[j];

    regRefArray[readIdxInst][pairIdxInst][regIdxInst][2].rBeg = rBegArray[2];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][2].rEnd = rEndArray[2];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][2].len = lenArray[2];
    if(lenArray[2] > 0) {
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][2].ref = (uint8_t*) malloc(sizeof(uint8_t) * lenArray[2]);
      assert(regRefArray[readIdxInst][pairIdxInst][regIdxInst][2].ref != NULL);
    }
    for(j = 0; j < lenArray[2]; j++)
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][2].ref[j] = ref2[j];

    regRefArray[readIdxInst][pairIdxInst][regIdxInst][3].rBeg = rBegArray[3];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][3].rEnd = rEndArray[3];
    regRefArray[readIdxInst][pairIdxInst][regIdxInst][3].len = lenArray[3];
    if(lenArray[3] > 0) {
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][3].ref = (uint8_t*) malloc(sizeof(uint8_t) * lenArray[3]);
      assert(regRefArray[readIdxInst][pairIdxInst][regIdxInst][3].ref != NULL);
    }
    for(j = 0; j < lenArray[3]; j++)
      regRefArray[readIdxInst][pairIdxInst][regIdxInst][3].ref[j] = ref3[j];

#ifdef DEBUG
    for(j = 0; j < 4; j++) 
      if(lenArray[j] <= 0) {
        fprintf(stderr, "[DEBUG] len: %ld, rBeg: %ld, rEnd: %ld\n", lenArray[j], rBegArray[j], rEndArray[j]);
        fprintf(stderr, "%d %d %d %d\n", readIdxInst, pairIdxInst, regIdxInst, j);
        if(regRefArray[readIdxInst][pairIdxInst][regIdxInst][j].ref == NULL) 
          fprintf(stderr, "[DEBUG] NULL Ptr\n");
      }
#endif
      //else
        //fprintf(stderr, "%d %d %d %d %p\n", readIdxInst, pairIdxInst, regIdxInst, j, regRefArray[readIdxInst][pairIdxInst][regIdxInst][j].ref);

/*   
    j = 0;
    for(j = 0; j < 4; j++) {
      fprintf(stderr, "%ld %ld %ld\n", rBegArray[j], rEndArray[j], lenArray[j]);
      int k = 0;

      if(j == 0) {
        for(k = 0; k < lenArray[0]; k++)
          fprintf(stderr, "%c", ref0[k] + 48);
        fprintf(stderr, "\n");
      }
      else if(j == 1) {
        for(k = 0; k < lenArray[1]; k++)
          fprintf(stderr, "%c", ref1[k] + 48);
        fprintf(stderr, "\n");
      }
      else if(j == 2) {
        for(k = 0; k < lenArray[2]; k++)
          fprintf(stderr, "%c", ref2[k] + 48);
        fprintf(stderr, "\n");
      }
      else if(j == 3) {
        for(k = 0; k < lenArray[3]; k++)
          fprintf(stderr, "%c", ref3[k] + 48);
        fprintf(stderr, "\n");
      }
    }    
*/

    (*env)->ReleaseLongArrayElements(env, *rBegArrayPtr, rBegArray, 0);
    (*env)->ReleaseLongArrayElements(env, *rEndArrayPtr, rEndArray, 0);
    if(lenArray[0] > 0)
      (*env)->ReleaseByteArrayElements(env, *ref0Ptr, ref0, 0);
    if(lenArray[1] > 0)
      (*env)->ReleaseByteArrayElements(env, *ref1Ptr, ref1, 0);
    if(lenArray[2] > 0)
      (*env)->ReleaseByteArrayElements(env, *ref2Ptr, ref2, 0);
    if(lenArray[3] > 0)
      (*env)->ReleaseByteArrayElements(env, *ref3Ptr, ref3, 0);
    (*env)->ReleaseLongArrayElements(env, *lenArrayPtr, lenArray, 0);

    //if(i % 10000 == 0) fprintf(stderr, "%d\n", i);
  }

  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

  // debugging
#ifdef DEBUG
  long sum = 0;
  for(i = 0; i < groupSize; i++) {
    int j = 0;
    for(j = 0; j < 2; j++) {
      sum += alnRegVecPairs[i][j].n;
    }
  }
  fprintf(stderr, "Total alnReg # received: %ld\n", sum);
#endif

  mem_group_matesw(&optC, (int64_t) pacLen, pesC, groupSize, seqLenPairs, seqsTransPairs, regRefArray, &alnRegVecPairs);

/*
  for(i = 0; i < groupSize; i++) {
    int j = 0;
    for(j = 0; j < 2; j++) {
      int k = 0;
      for(k = 0; k < alnRegVecPairs[i][j].n; k++)
        fprintf(stderr, "RegF: %ld %ld %d %d %d %d %d %d %d %d %d %d %"PRIu64"\n", alnRegVecPairs[i][j].a[k].rb, alnRegVecPairs[i][j].a[k].re, alnRegVecPairs[i][j].a[k].qb, alnRegVecPairs[i][j].a[k].qe, alnRegVecPairs[i][j].a[k].score, alnRegVecPairs[i][j].a[k].truesc, alnRegVecPairs[i][j].a[k].sub, alnRegVecPairs[i][j].a[k].csub, alnRegVecPairs[i][j].a[k].sub_n, alnRegVecPairs[i][j].a[k].w, alnRegVecPairs[i][j].a[k].seedcov, alnRegVecPairs[i][j].a[k].secondary, alnRegVecPairs[i][j].a[k].hash);
    }
  }
*/  

  // Calculate the return array size
  int retArraySize = 0;
  for(i = 0; i < groupSize; i++) {
    int j = 0;
    for(j = 0; j < 2; j++) 
      retArraySize += alnRegVecPairs[i][j].n;
  }

#ifdef DEBUG
  fprintf(stderr, "[DEBUG] retArraySize: %d\n", retArraySize);
#endif

  // Allocate the object array to be returned
  jobjectArray ret = (*env)->NewObjectArray(env, retArraySize, MateSWTypeClass, NULL);
  int retArrayIdx = 0;

  for(i = 0; i < groupSize; i++) {
    int j = 0;
    for(j = 0; j < 2; j++) {
      int k = 0;
      for(k = 0; k < alnRegVecPairs[i][j].n; k++) {
        jobject alnObj = (*env)->AllocObject(env, MateSWTypeClass);
        (*env)->SetIntField(env, alnObj, readIdxId, i);
        (*env)->SetIntField(env, alnObj, pairIdxId, j);
        (*env)->SetIntField(env, alnObj, regIdxId, k);
        jobject alnRegObj = (*env)->AllocObject(env, MemAlnRegTypeClass);
        (*env)->SetLongField(env, alnRegObj, rBegId, (long) alnRegVecPairs[i][j].a[k].rb);
        (*env)->SetLongField(env, alnRegObj, rEndId, (long) alnRegVecPairs[i][j].a[k].re);
        (*env)->SetIntField(env, alnRegObj, qBegId, alnRegVecPairs[i][j].a[k].qb);
        (*env)->SetIntField(env, alnRegObj, qEndId, alnRegVecPairs[i][j].a[k].qe);
        (*env)->SetIntField(env, alnRegObj, scoreId, alnRegVecPairs[i][j].a[k].score);
        (*env)->SetIntField(env, alnRegObj, trueScoreId, alnRegVecPairs[i][j].a[k].truesc);
        (*env)->SetIntField(env, alnRegObj, subId, alnRegVecPairs[i][j].a[k].sub);
        (*env)->SetIntField(env, alnRegObj, csubId, alnRegVecPairs[i][j].a[k].csub);
        (*env)->SetIntField(env, alnRegObj, subNumId, alnRegVecPairs[i][j].a[k].sub_n);
        (*env)->SetIntField(env, alnRegObj, widthId, alnRegVecPairs[i][j].a[k].w);
        (*env)->SetIntField(env, alnRegObj, seedCovId, alnRegVecPairs[i][j].a[k].seedcov);
        (*env)->SetIntField(env, alnRegObj, secondaryId, alnRegVecPairs[i][j].a[k].secondary);
        (*env)->SetLongField(env, alnRegObj, hashId, (long) alnRegVecPairs[i][j].a[k].hash);
        (*env)->SetObjectField(env, alnObj, alnRegId, alnRegObj);
        (*env)->SetObjectArrayElement(env, ret, retArrayIdx, alnObj);
        retArrayIdx++;
      }
    }
  }

#ifdef DEBUG
  fprintf(stderr, "[DEBUG] retArrayIdx: %d\n", retArrayIdx);
#endif

  // free memory
#ifdef DEBUG
  fprintf(stderr, "[DEBUG] Free seqLenPairs\n");
#endif
  for(i = 0; i < groupSize; i++) free(seqLenPairs[i]); 
  free(seqLenPairs);
  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

#ifdef DEBUG
  fprintf(stderr, "[DEBUG] Free seqsTransPairs\n");
#endif
  for(i = 0; i < groupSize; i++) {
    int j = 0;
    for(j = 0; j < 2; j++) free(seqsTransPairs[i][j]);
    free(seqsTransPairs[i]);
  }
  free(seqsTransPairs);
  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

#ifdef DEBUG
  fprintf(stderr, "[DEBUG] Free regRefArray\n");
#endif
  for(i = 0; i < groupSize; i++) {
    int j = 0;
    for(j = 0; j < 2; j++) {
      int k = 0;
      for(k = 0; k < refSizeArrayC[i * 2 + j]; k++) {
        int r = 0;
        for(r = 0; r < 4; r++) {
          if(regRefArray[i][j][k][r].ref != NULL) free(regRefArray[i][j][k][r].ref);
          //if(regRefArray[i][j][k][r].ref == NULL)
            //fprintf(stderr, "NULL: %d %d %d %d %p\n", i, j, k, r, regRefArray[i][j][k][r].ref);
          //else
            //fprintf(stderr, "%d %d %d %d %p\n", i, j, k, r, regRefArray[i][j][k][r].ref);
        }
        free(regRefArray[i][j][k]);
      }
      free(regRefArray[i][j]);
    }
    free(regRefArray[i]);
    //fprintf(stderr, "Free: %d %p\n", i, regRefArray[i]);
  }
  free(regRefArray);
  //fprintf(stderr, "Free: %p\n", regRefArray);
  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);

#ifdef DEBUG
  fprintf(stderr, "[DEBUG] Free alnRegVecPairs\n");
#endif
  for(i = 0; i < groupSize; i++) {
    int j = 0;
    for(j = 0; j < 2; j++) {
      free(alnRegVecPairs[i][j].a);
    }
    free(alnRegVecPairs[i]);
  }
  free(alnRegVecPairs);
  //fprintf(stderr, "[DEBUG] Total allocated: %d\n", total_allocated);
#ifdef DEBUG
  fprintf(stderr, "[JNI] mem_group_matesw() complete\n");
#endif

  (*env)->ReleaseIntArrayElements(env, refSizeArray, refSizeArrayC, 0);

  return ret;
}
